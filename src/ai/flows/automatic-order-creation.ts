'use server';

/**
 * @fileOverview Automatically creates orders based on active subscriptions.
 *
 * - automaticOrderCreation - A function that handles the automatic order creation process.
 *
 * OPTIMIZED VERSION:
 * - Batched reads for Subscriptions, Users, Products, and Existing Orders.
 * - In-memory processing of business logic.
 * - Batched writes (Transactions in chunks) for creating Orders and updating Counters.
 */

import { ai } from '@/ai/genkit';
import { z } from 'genkit';
import {
  AutomaticOrderCreationInputSchema,
  AutomaticOrderCreationOutputSchema,
  type AutomaticOrderCreationInput,
  type AutomaticOrderCreationOutput,
  type Subscription,
  type Order,
  type OrderItem,
  type User,
  type Product,
} from '@/lib/types';
import { adminDb } from '@/lib/server/firebase';
import { Timestamp } from 'firebase-admin/firestore';
import { startOfDay, isWeekend, differenceInDays } from 'date-fns';

// Helper to fetch documents by IDs in chunks to avoid limits
async function fetchDocsByIds<T>(collectionName: string, ids: string[]): Promise<Map<string, T>> {
  const result = new Map<string, T>();
  const uniqueIds = Array.from(new Set(ids));
  const CHUNK_SIZE = 100; // distinct doc limit for getAll is usually higher, but 100 is safe

  for (let i = 0; i < uniqueIds.length; i += CHUNK_SIZE) {
    const chunk = uniqueIds.slice(i, i + CHUNK_SIZE);
    if (chunk.length === 0) continue;

    const refs = chunk.map(id => adminDb.doc(`${collectionName}/${id}`));
    // getAll is efficient for fetching multiple docs
    const snapshots = await adminDb.getAll(...refs);

    snapshots.forEach(snap => {
      if (snap.exists) {
        result.set(snap.id, snap.data() as T);
      }
    });
  }
  return result;
}

export async function automaticOrderCreation(
  input: AutomaticOrderCreationInput
): Promise<AutomaticOrderCreationOutput> {
  return automaticOrderCreationFlow(input);
}

const automaticOrderCreationFlow = ai.defineFlow(
  {
    name: 'automaticOrderCreationFlow',
    inputSchema: AutomaticOrderCreationInputSchema,
    outputSchema: AutomaticOrderCreationOutputSchema,
  },
  async (input) => {
    console.log('Starting automatic order creation flow (Optimized)...');
    const now = new Date();
    const todayStart = startOfDay(now);
    const todayStr = todayStart.toISOString();

    // 1. Fetch ALL active subscriptions
    // This is a single query.
    const subscriptionsSnapshot = await adminDb
      .collection('subscriptions')
      .where('isActive', '==', true)
      .get();

    if (subscriptionsSnapshot.empty) {
      console.log('No active subscriptions found.');
      return { ordersCreated: 0 };
    }

    const subscriptions = subscriptionsSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    })) as Subscription[];

    console.log(`Found ${subscriptions.length} active subscriptions.`);

    // 2. Fetch Existing Orders for Today (Idempotency)
    // We only care about orders generated by subscription for today's date.
    const existingOrdersSnapshot = await adminDb
      .collection('orders')
      .where('deliveryDate', '==', todayStr)
      .where('orderType', '==', 'SUBSCRIPTION_GENERATED')
      .get();

    // Create a Set of subscriptionIds that have already been processed today
    const processedSubscriptionIds = new Set<string>();
    existingOrdersSnapshot.forEach(doc => {
      const order = doc.data() as Order;
      if (order.subscriptionId) {
        processedSubscriptionIds.add(order.subscriptionId);
      }
    });

    // 3. Filter Subscriptions & Collect Dependencies
    const userIdsToFetch: string[] = [];
    const productIdsToFetch: string[] = [];
    const candidateSubscriptions: Subscription[] = [];

    for (const sub of subscriptions) {
      // a. Idempotency Check
      if (processedSubscriptionIds.has(sub.id)) {
        continue;
      }

      // b. End Date Check
      if (sub.endDate) {
        const endDate = sub.endDate instanceof Timestamp ? sub.endDate.toDate() : new Date(sub.endDate);
        if (startOfDay(endDate) < todayStart) continue;
      }

      // c. Start Date Check
      const startDate = sub.startDate instanceof Timestamp ? sub.startDate.toDate() : new Date(sub.startDate);
      if (startOfDay(startDate) > todayStart) continue;

      // d. Frequency Logic
      let shouldCreateOrder = false;
      switch (sub.frequency) {
        case 'DAILY':
          shouldCreateOrder = true;
          break;
        case 'WEEKEND':
          shouldCreateOrder = isWeekend(now);
          break;
        case 'ALTERNATE':
          const daysDiff = differenceInDays(todayStart, startOfDay(startDate));
          shouldCreateOrder = daysDiff % 2 === 0;
          break;
        case 'CUSTOM':
          if (sub.customDays && sub.customDays.length > 0) {
            shouldCreateOrder = sub.customDays.includes(now.getDay());
          }
          break;
      }

      if (!shouldCreateOrder) continue;
      if (!sub.items || sub.items.length === 0) continue;

      // If valid, add to candidates and collect IDs
      candidateSubscriptions.push(sub);
      userIdsToFetch.push(sub.customerId);
      sub.items.forEach(item => productIdsToFetch.push(item.productId));
    }

    if (candidateSubscriptions.length === 0) {
      console.log('No eligible subscriptions for today.');
      return { ordersCreated: 0 };
    }

    console.log(`Processing ${candidateSubscriptions.length} eligible subscriptions...`);

    // 4. Batch Fetch Users and Products
    const [usersMap, productsMap] = await Promise.all([
      fetchDocsByIds<User>('users', userIdsToFetch),
      fetchDocsByIds<Product>('products', productIdsToFetch),
    ]);

    // 5. Prepare Order Objects in Memory
    const newOrders: Order[] = [];

    for (const sub of candidateSubscriptions) {
      const user = usersMap.get(sub.customerId);
      if (!user) {
        console.warn(`User ${sub.customerId} not found for subscription ${sub.id}`);
        continue;
      }

      const orderItems: OrderItem[] = [];
      let totalAmount = 0;
      let allProductsFound = true;

      for (const item of sub.items) {
        const product = productsMap.get(item.productId);
        if (!product) {
          console.warn(`Product ${item.productId} not found for subscription ${sub.id}`);
          allProductsFound = false;
          break;
        }

        const priceAtOrder = product.pricePerUnit || 0;
        const amount = priceAtOrder * item.qty;
        totalAmount += amount;

        orderItems.push({
          productId: item.productId,
          qty: item.qty,
          priceAtOrder,
          isCut: false,
          cutCharge: 0,
          name: product.name,
          name_te: product.name_te,
          unit: product.unit,
        });
      }

      if (!allProductsFound) continue;

      // We will assign ID later
      const newOrder: Order = {
        id: '', // Placeholder
        customerId: sub.customerId,
        name: user.name || 'Unknown',
        phone: user.phone || '',
        address: sub.area || user.address || '',
        deliveryPlace: 'Home',
        items: orderItems,
        totalAmount,
        paymentMode: 'COD',
        orderType: 'SUBSCRIPTION_GENERATED',
        area: sub.area,
        deliverySlot: sub.deliverySlot,
        deliveryDate: todayStr,
        status: 'PENDING',
        createdAt: new Date(),
        subscriptionId: sub.id,
      };

      newOrders.push(newOrder);
    }

    // 6. Write Orders in Chunks (Transactional ID generation)
    const WRITE_CHUNK_SIZE = 400; // Limit is 500, keeping safe buffer
    let ordersCreatedCount = 0;

    for (let i = 0; i < newOrders.length; i += WRITE_CHUNK_SIZE) {
      const chunk = newOrders.slice(i, i + WRITE_CHUNK_SIZE);

      try {
        await adminDb.runTransaction(async (transaction) => {
          const counterRef = adminDb.doc('counters/orders');
          const counterDoc = await transaction.get(counterRef);

          let currentLastId = 1000;
          if (counterDoc.exists) {
            const data = counterDoc.data();
            if (data && typeof data.lastId === 'number') {
              currentLastId = data.lastId;
            }
          }

          // Assign IDs
          chunk.forEach((order, index) => {
             const nextId = currentLastId + index + 1;
             order.id = `ORD-${nextId}`;
             const orderRef = adminDb.doc(`orders/${order.id}`);
             transaction.set(orderRef, order);
          });

          // Update Counter
          const newLastId = currentLastId + chunk.length;
          transaction.set(counterRef, { lastId: newLastId }, { merge: true });
        });

        ordersCreatedCount += chunk.length;
        console.log(`Successfully batch created ${chunk.length} orders.`);

      } catch (error) {
        console.error(`Failed to create batch of orders (chunk starting index ${i}):`, error);
        // Optionally continue to next chunk or halt?
        // We'll log and continue to try to save as many as possible.
      }
    }

    return { ordersCreated: ordersCreatedCount };
  }
);
